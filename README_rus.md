## Форматирование исходного кода в Linux

Статья рассказывает об одном из способов форматирования исходного кода средствами _clang-format_, _git_ и _sh_.

### Проблемы с форматированием

Согласитесь, приятно и полезно, когда в проекте исходный код выглядит красиво и единообразно. Это облегчает его понимание и поддержку. В большинстве проектов, которые я встречал, существуют определенные правила оформления кода. Добиться выполнения этих правил всеми участниками проекта иногда нелегко. Тогда на помощь приходят специальные программы, такие как _clang-format, astyle, uncrustify_. Но форматирование кода этими программами может вызывать некоторые проблемы. Самая главная в том, что форматеры меняют файлы целиком, а не только изменённые строки. Эту проблему мы решили на одном из проектов. Для форматирования кода использовали программу _clang-format-diff-6.0_. Поначалу, это делалось командой _git diff -U0 --no-color | clang-format-diff-6.0 -i -p1_. Но с ней возникали проблемы:

*   Программа определяла типы файлов только по расширению. Например, файлы с расширением ts, которые у нас имели формат xml, воспринимала как JavaScript и валилась при форматировании. Потом, она зачем то пыталась поправить pro-файлы проектов Qt, наверное, как Protobuf
*   Надо было запускать вручную, перед добавлением в индекс git. Можно легко забыть это сделать

### Решение

В результате получился следующий sh-скрипт запускаемый как _pre-commit_ хук для git:

<pre>#!/bin/sh

CLANG_FORMAT="clang-format-diff-6.0 -p1 -v -sort-includes -style=Chromium -iregex '.*\.(cxx|cpp|hpp|h)/pre> "
GIT_DIFF="git diff -U0 --no-color "
GIT_APPLY="git apply -v -p0 - "
FORMATTER_DIFF=$(eval ${GIT_DIFF} --staged | eval ${CLANG_FORMAT})

echo  "\n------Format code hook has called-------"

if [ -z "${FORMATTER_DIFF}" ]; then
	echo "Nothing to be formatted"
else
	echo "${FORMATTER_DIFF}"
	echo "${FORMATTER_DIFF}" | eval ${GIT_APPLY} --cached
	echo "      ---Format of staged area completed. Begin format unstaged files---"
	eval ${GIT_DIFF} | eval ${CLANG_FORMAT} | eval ${GIT_APPLY}
fi

echo "------Format code hook has completed----\n"
exit 0

</pre>

Что делает скрипт:  
**GIT_DIFF="git diff -U0 --no-color "** изменения в коде которые подадут на вход _clang-format-diff-6.0_

*   **-U0** обычно git diff выводит т.н. "контекст" несколько неизменёных строк кода вокруг тех что были изменены. Но _clang-format-diff-6.0_ форматирует их тоже! Поэтому, контекст в данном случае не нужен

**CLANG_FORMAT="clang-format-diff-6.0 -p1 -v -sort-includes -style=Chromium -iregex '.*\.(cxx|cpp|hpp|h)$' "** команда для форматирования diff полученного через стандартный ввод

*   **clang-format-diff-6.0** скрипт из пакета _clang-format-6.0_ . Есть другие версии, но все тесты были только на этой
*   **-p1** взято из примеров в [документации](http://clang.llvm.org/docs/ClangFormat.html). Так понимаю это обеспечивает совместимость с выводом _git diff_
*   **-style=Chromium** готовый пресет стиля форматирования кода. Возможные значения так же: _LLVM, Google, Mozilla, WebKit_.
*   **-sort-includes** опция сортировки по алфавиту директив _#include_ . Не обязательна
*   **-iregex '.*\.(cxx|cpp|hpp|h)$'** регулярное выражение фильтрующее имена файлов по расширениям. Тут перечислены только те расширения которые надо форматировать. Это убережёт программу от падения и неожиданных глюков. Скорее всего для вас, список надо дополнить. Кроме С++ можно форматировать _C/Objective-C/JavaScript/Java/Protobuf_ файлы. Хотя эти остальные типы мы не тестировали

**GIT_APPLY="git apply -v -p0 - "** применение патча выданного предыдущей командой к коду

*   **-p0** по умолчанию _git apply_ пропускает первый компонент в пути к файлу, это несовместимо с форматом который выдаёт _clang-format-diff-6.0_ . Здесь отключено такое пропускание

**FORMATTER_DIFF=$(eval ${GIT_DIFF} --staged | eval ${CLANG_FORMAT})** изменения форматера для индекса

**echo "${FORMATTER_DIFF}" | eval ${GIT_APPLY} --cached** форматирует исходный код в индексе(после _git add_). К сожалению, нет такого хука который срабатывал бы перед добавлением файлов в индекс. Поэтому форматирование разделено на две части, того что в индексе и того что не добавлено в индекс.

**eval ${GIT_DIFF} | eval ${CLANG_FORMAT} | eval ${GIT_APPLY}** форматирование кода не в индексе. Запускается только когда что-то было отформатировано в индексе. Форматирует вообще все текущие изменения в проекте(под контролем версий), а не только из предыдущего шага. Это спорное, на первый взгляд решение. Но оно оказалось удобным т.к. рано или поздно все изменения надо форматировать тоже. Можно заменить _"| eval ${GIT_APPLY}"_ опцией _-i_ которая заставит _${CLANG_FORMAT}_ менять файлы самостоятельно

### Демонстрация работы

1.  Установить _clang-format-6.0_
2.  **cd /tmp && mkdir temp_project && cd temp_project**
3.  **git init**
4.  Добавить под контроль версий и закомитить любой C++ файл под именем _wrong.cpp_ . Желательно >50 строк неформатированого кода
5.  Сделать скрипт _.git/hooks/pre-commit_ с содержимым выше

**chmod +x .git/hooks/pre-commit**

7.  Запустить скрипт вручную **.git/hooks/pre-commit** Он должен запускаться с сообщением _"Nothing to be formatted"_, без ошибок интерпретатора
8.  Создать _file.cpp_ с содержимым _int main() { for (int i = 0; i < 100; ++i) { std::cout << "First case" << std::endl; std::cout << "Second case" << std::endl; std::cout << "Third case" << std::endl; } }_ одной строкой, либо с другим плохим форматированием. В конце перевод строки!
9.  **git add file.cpp && git commit -m "file.cpp"** должны быть сообщения от скрипта типа _"Патч file.cpp применен без ошибок"_
10.  **git log -p -1** должен показать добавление форматированного файла
11.  Если _file.cpp_ попал в коммит действительно форматированным, значит можно тестировать форматирование только в diff. Измените пару строк _wrong.cpp_, так что-бы форматер на них среагировал. Например, добавить неадекватные отступы в коде, вместе с другими изменениями. **git commit -a -m "Format only diff"** должен залить форматированные изменения, но не тронуть другие части файла

### Недостатки и проблемы

_git diff --staged_ ( который здесь _${GIT_DIFF} --staged_) выдаёт diff только файлов добавленных в индекс. А _clang-format-diff-6.0_ обращается к полным версиям файлов за пределами него. Поэтому, если изменить какой то файл сделать _git add_, потом изменить тот же файл. _clang-format-diff-6.0_ будет генерировать патч для форматирования кода (в индексе) на основе отличающегося файла. Таким образом файл после _git add_ и до коммита, лучше не редактировать. Ниже пример такой ошибки.

1.  Добавить в _file.cpp_ , _"Second case"_ лишний _std::endl_. _(std::cout << "Second case" << std::endl << std::endl;)_ и добавляете несколько табов лишнего отступа перед строкой.
2.  **git add file.cpp**
3.  Очистить строку(в этом же файле) с _"First case"_ так что бы на её месте остался(!) только перенос строки
4.  **git commit -m "Formatter error on commit"**

Скрипт должен сообщить _"error: при поиске:"_ т.е. _git apply_ не нашёл контекст патча, выданного _clang-format-diff-6.0_. Если вы не поняли в чём тут проблема, просто не меняйте файлы после _git add_ их и до _git commit_. Если надо поменять, можете сделать коммит(без push) и потом _git commit --amend_ с новыми изменениями.

Самое серьёзное ограничение - необходимость иметь в конце каждого файла перевод строки. Это старая особенность git, поэтому большинство редакторов кода, поддерживают автоматическую вставку такого перевода в конец файла. Без этого скрипт будет падать при коммите нового файла, но это не принесет никакого вреда

Очень редко, _clang-format-diff-6.0_ форматирует код неадекватно. В этом случае, можно добавить какие-нибудь бесполезные элементы в код, типа точки с запятой. Либо, окружить проблемный код комментариями, _/* clang-format off */_ и _/* clang-format on */_.

### Отладка

Если хотите посмотреть, какие изменения сделает скрипт на ваших текущих правках(не в индексе), используйте **git diff -U0 --no-color | clang-format-diff-6.0 -p1 -v -sort-includes -style=Chromium -iregex '.*\.(cxx|cpp|hpp|h)$'** Так же можно проверить, как будет работать скрипт на последних(30-и) коммитах **git filter-branch -f --tree-filter "${PWD}/.git/hooks/pre-commit " --prune-empty HEAD~30..HEAD** . Данная команда должна была форматировать предыдущие коммиты, но по факту меняет только их id. Поэтому, такие эксперименты в отдельной копии проекта! После она станет непригодной для работы.

### Заключение

Субъективно, от такого решения гораздо больше пользы чем вреда. Но надо тестировать поведение _clang-format-diff_ разных версий, на коде вашего проекта, с конфигом подходящим под ваш стиль кода.

К сожалению, такой же git-hook для Windows сделан не был. Если хотите статью для быстрого старта с _clang-format_, загляните [сюда](http://clang.llvm.org/docs/ClangFormat.html).